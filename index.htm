<!DOCTYPE html><html><head><title>Polyomino</title><meta charset="UTF-8">
<body bgcolor="000000"><canvas id="canvas" width="512" height="512"></canvas>
<div style="font:48px arial;letter-spacing:-3px;font-weight:800;color:white;">Polyomino</div>
<script type="text/javascript">

/*+==========================================================================+*\
                   ___  ____  ____  ______  __  ________  ______ 
                  / _ \/ __ \/ /\ \/ / __ \/  |/  /  _/ |/ / __ \
                 / ___/ /_/ / /__\  / /_/ / /|_/ // //    / /_/ /
                /_/   \____/____//_/\____/_/  /_/___/_/|_/\____/ 

// TODO: optimize everything, pretty much all verification algos are extremely inefficient
// TODO: GET RID OF THE UNNECESSARY RECURSION XXX XXX XXX XXX XXX XXX XXX XXX

\*+==========================================================================+*/

var canvas = document.getElementById("canvas");
var gfx = canvas.getContext("2d");
var ww = canvas.width;
var wh = canvas.height;
var tick,elapsed;
function rfloat(x){return Math.random()*x;}
function rInt(x){return Math.floor(Math.random()*x);}

//==  MISC RENDERING  ========================================================//

function setFillColor(r,g,b){gfx.fillStyle="rgb("+Math.floor(255*r)+","+Math.floor(255*g)+","+Math.floor(255*b)+")";}

function hsv(h,s,v){
	var r,g,b,i,f,p,q,t;
	if (h&&s===undefined&&v===undefined)s=h.s,v=h.v,h=h.h;
	i = Math.floor(h*6);
	f = h*6-i;
	p = v*(1-s);
	q = v*(1-f*s);
	t = v*(1-(1-f)*s);
	switch(i%6){
		case 0:r=v,g=t,b=p;break;
		case 1:r=q,g=v,b=p;break;
		case 2:r=p,g=v,b=t;break;
		case 3:r=p,g=q,b=v;break;
		case 4:r=t,g=p,b=v;break;
		case 5:r=v,g=p,b=q;break;
	}gfx.fillStyle="rgb("+Math.floor(255*r)+","+Math.floor(255*g)+","+Math.floor(255*b)+")";
}

function renderRect(x0,y0,x1,y1){
	gfx.beginPath();
	gfx.moveTo(x0,y0);
	gfx.lineTo(x0,y1);
	gfx.lineTo(x1,y1);
	gfx.lineTo(x1,y0);
	gfx.fill();
}

//==  GRID RELATED  ==========================================================//

var grid = function(size){
	var grid = [];
	grid.size = size;
	for(var i=0;i<size;++i){
		grid[i] = [];
		for(var j=0;j<size;++j)grid[i][j] = null;
	}

	grid.getCell = function(x,y){
		x = Math.floor(x);
		y = Math.floor(y);
		if(x<0||y<0||x>=grid.size||y>=grid.size)return undefined;
		return grid[x][y];
	}

	return grid;
}

var cell = function(id,order){
	this.id = id;
	this.order = order;
}

//==  GAME VARIABLES  ========================================================//

var polyColor = ["#f00","#0f0","#00f","#0ff","#f0f","#0ff","#fff"];
var goldenAngle = 0.381966;
var board,blockId,floating,score;
var mouse,dragging,mouseDX,mouseDY,downGX,downGY,mouseGX,mouseGY;
var goalFloatX,goalFloatY,floatX,floatY;
var cs = 32;

function newId(){return ++blockId;}

//==  VERIFICATION FUNCTIONS  ================================================//

function recalculateIds(){
	// detect sliced polys, reassign new ids
	var visited = new grid(board.size);
	for(var i=0;i<board.size;++i)
	for(var j=0;j<board.size;++j){
		var c = board[i][j];
		if(c){
			var recurse = function(x,y){
				if(x<0||y<0||x>=visited.size||y>=visited.size)return;
				if(!board[x][y])return;
				if(board[i][j].id !== board[x][y].id)return;
				if(visited[x][y])return;
				visited[x][y] = true;
				recurse(x,y-1);
				recurse(x,y+1);
				recurse(x-1,y);
				recurse(x+1,y);
			};

			recurse(i,j);
			var id = newId();
			for(var x=0;x<board.size;++x)
			for(var y=0;y<board.size;++y){
				var chk = board[x][y];
				if(chk&&chk.id === c.id&&!visited[x][y])
					chk.id = id;
			}
		}
	}
}

function recalculateOrder(){
	for(var i=0;i<board.size;++i)
	for(var j=0;j<board.size;++j)
	if(board[i][j]){
		// determine real order of cell
		var count = 0;
		var visited = new grid(board.size,board.size);
		var recurse = function(x,y){
			if(x<0||y<0||x>=visited.size||y>=visited.size)return;
			if(!board[x][y])return;
			if(board[i][j].id !== board[x][y].id)return;
			if(visited[x][y])return;
			visited[x][y] = true;
			++count;
			recurse(x,y-1);
			recurse(x,y+1);
			recurse(x-1,y);
			recurse(x+1,y);
		};

		recurse(i,j);

		// if counted order doesnt match assigned order,reassign
		if(count != board[i][j].order){
			var visited = new grid(board.size,board.size);
			var recurse = function(x,y){
				if(x<0||y<0||x>=visited.size||y>=visited.size)return;
				if(!board[x][y])return;
				if(board[i][j].id !== board[x][y].id)return;
				if(visited[x][y])return;
				visited[x][y] = true;
				board[x][y].order = count;
				recurse(x,y-1);
				recurse(x,y+1);
				recurse(x-1,y);
				recurse(x+1,y);
			};

			recurse(i,j);
		}
	}
}

function detectSquares(){
	var squareCount = 0;
	for(var x=0;x<board.size;++x)
	outer:for(var y=0;y<board.size;++y)
	if(board[x][y]){
		var n = board[x][y].order;
		if(x+n>=board.size||y+n>=board.size)continue outer;
		for(var i=x;i<x+n+1;++i)
		for(var j=y;j<y+n+1;++j){
			var c = board.getCell(i,j);
			if(!c)continue outer;
			if(c.order !== n)continue outer;
		}squareToPoly(x,y,n+1);
		++squareCount;
	}

	// placing these here rather than right after squareToPoly allows for comboing
	recalculateIds();
//	recalculateOrder();
	if(squareCount>0)detectSquares();
}

//==  GENERATION FUNCTIONS  ==================================================//

function placeNewPoly(){
	var x,y;
	while(true){
		x = rInt(board.size);
		y = rInt(board.size);
		if(!board.getCell(x,y))break;
	}

	var id = newId();
	board[x][y] = new cell(id,1);
	switch(rInt(4)){
		case 0:if(board.getCell(x,y-1) === null){board[x][y-1] = new cell(id,2);board.getCell(x,y).order = 2;}break;
		case 1:if(board.getCell(x,y+1) === null){board[x][y+1] = new cell(id,2);board.getCell(x,y).order = 2;}break;
		case 2:if(board.getCell(x-1,y) === null){board[x-1][y] = new cell(id,2);board.getCell(x,y).order = 2;}break;
		case 3:if(board.getCell(x+1,y) === null){board[x+1][y] = new cell(id,2);board.getCell(x,y).order = 2;}break;
	}

	detectSquares();
}

function squareToPoly(x,y,order){
	outer:while(true){
		var filled = new grid(order,order);

		// clear everything in bounding box
		for(var i=x;i<x+order;++i)
		for(var j=y;j<y+order;++j)
			board[i][j] = null;

		// generate random polyomino
		var id = newId();
		var i=x+rInt(order);
		var j=y+rInt(order);
		board[i][j] = new cell(id,order);
		filled[i-x][j-y] = true;
		for(var count=1;count<order;++count)while(true){
			i=x+rInt(order);
			j=y+rInt(order);
			if(board[i][j])continue;
			var u = filled.getCell(i-x  ,j-y-1);
			var d = filled.getCell(i-x  ,j-y+1);
			var l = filled.getCell(i-x-1,j-y  );
			var r = filled.getCell(i-x+1,j-y  );
			if(!(u||d||l||r))continue;
			board[i][j] = new cell(id,order);
			filled[i-x][j-y] = true;
			break;
		}

		// assure poly has no holes
		var recurse = function(x,y){
			if(x<0||y<0||x>=filled.size||y>=filled.size)return;
			if(filled[x][y])return;
			filled[x][y] = true;
			recurse(x,y-1);
			recurse(x,y+1);
			recurse(x-1,y);
			recurse(x+1,y);
		};

		while(true){
			i=rInt(order);
			j=rInt(order);
			if(!filled[i][j])break;
		}recurse(i,j);

		for(var i=0;i<order;++i)
		for(var j=0;j<order;++j)
			if(!filled[i][j])continue outer;
		break;
	}
}

//==  MAIN LOOP  =============================================================//

function renderGrid(g){
	for(var i=0;i<g.size;++i)
	for(var j=0;j<g.size;++j){
		var c = g[i][j];
		if(c){
			hsv((c.order*goldenAngle)%1,1,0.7);
			renderRect(i*cs+1,j*cs+1,(i+1)*cs-1,(j+1)*cs-1);
			var right = g.getCell(i+1,j);
			if(right&&right.id === c.id)renderRect((i+1)*cs-2,j*cs+1,(i+1)*cs+2,(j+1)*cs-1);
			var down = g.getCell(i,j+1);
			if(down&&down.id === c.id)renderRect(i*cs+1,(j+1)*cs-2,(i+1)*cs-1,(j+1)*cs+2);
		}
	}

	for(var i=0;i<g.size;++i)
	for(var j=0;j<g.size;++j){
		var c = g[i][j];
		if(c){
			hsv((c.order*goldenAngle)%1,1,1);
			renderRect(i*cs+3,j*cs+3,(i+1)*cs-3,(j+1)*cs-3);
			var right = g.getCell(i+1,j);
			if(right&&right.id === c.id)renderRect((i+1)*cs-4,j*cs+3,(i+1)*cs+4,(j+1)*cs-3);
			var down = g.getCell(i,j+1);
			if(down&&down.id === c.id)renderRect(i*cs+3,(j+1)*cs-4,(i+1)*cs-3,(j+1)*cs+4);
		}
	}
}

function update(){
	requestAnimationFrame(update); // TODO: DONT RENDER IF NOTHINGS MOVING
	var currentTick = new Date().getTime();
	elapsed = currentTick-tick;
	tick = currentTick;
	gfx.clearRect(0,0,ww,wh);

	// render dot grid
	for(var i=0;i<board.size;++i)
	for(var j=0;j<board.size;++j){
		setFillColor(0.2,0.2,0.2);
		renderRect(i*cs+13,j*cs+13,(i+1)*cs-13,(j+1)*cs-13);
		setFillColor(0.4,0.4,0.4);
		renderRect(i*cs+15,j*cs+15,(i+1)*cs-15,(j+1)*cs-15);
	}

	// render board and floating layer
	renderGrid(board);
	floatX += (goalFloatX-floatX)*0.3;
	floatY += (goalFloatY-floatY)*0.3;
	if(dragging){
		gfx.save();
		gfx.translate(-floatX,-floatY);
		renderGrid(floating);
		gfx.restore();
	}

}

function newGame(){
	board = new grid(16);
	blockId = 0;
	score = 0;
	dragging = false;
	for(var i=0;i<4;++i)placeNewPoly();
}

//==  CONTROLS HANDLING  =====================================================//

function movePiece(from,to,id,offsetX,offsetY){
	for(var i=0;i<from.size;++i)
	for(var j=0;j<from.size;++j){
		var c = from.getCell(i+offsetX,j+offsetY);
		if(!c)continue;
		if(c.id !== id)continue;
		to[i][j] = c;
		from[i+offsetX][j+offsetY] = null;
	}
}

function calcMouseGridVars(){
	downGX  = Math.floor(mouseDX/cs);
	downGY  = Math.floor(mouseDY/cs);
	mouseGX = Math.floor(mouse.x/cs);
	mouseGY = Math.floor(mouse.y/cs);
}

function getMousePos(evt){
	var rect = canvas.getBoundingClientRect();
	return{x:evt.clientX-rect.left,y:evt.clientY-rect.top};
}

canvas.addEventListener("mousedown",function(e){
	mouse = getMousePos(e);
	if(dragging)return; // if ive somehow glitched into this state,keep holding whats being held
	var c = board.getCell(mouse.x/cs,mouse.y/cs);
	if(!c)return;

	// move selected piece onto floating layer,remove from board
	dragging = true;
	var id = c.id;
	var order = c.order;
	floating = new grid(board.size);
	movePiece(board,floating,c.id,0,0);

	mouseDX = mouse.x;
	mouseDY = mouse.y;
	calcMouseGridVars();
	floatX = goalFloatX = (downGX-mouseGX)*cs;
	floatY = goalFloatY = (downGY-mouseGY)*cs;
});

canvas.addEventListener("mousemove",function(e){
	mouse = getMousePos(e);
	if(!dragging)return;
	calcMouseGridVars();
	goalFloatX = (downGX-mouseGX)*cs;
	goalFloatY = (downGY-mouseGY)*cs;
});

canvas.addEventListener("mouseup",function(e){
	mouse = getMousePos(e);
	if(!dragging)return;
	dragging = false;

	calcMouseGridVars();
	var offsetX = downGX-mouseGX;
	var offsetY = downGY-mouseGY;

	// check if floating is dropped on original position
	if(downGX == mouseGX && downGY == mouseGY){
		movePiece(floating,board,floating.getCell(mouseDX/cs,mouseDY/cs).id,0,0);
		return;
	}

	// make sure pieces in floating and board aren't overlapping
	for(var i=0;i<board.size;++i)
	for(var j=0;j<board.size;++j)
	if(board.getCell(i,j))
	if(floating.getCell(i+offsetX,j+offsetY)){
		movePiece(floating,board,floating.getCell(mouseDX/cs,mouseDY/cs).id,0,0);
		return;
	}

	// make sure pieces in floating aren't out of bounds in board
	for(var i=0;i<floating.size;++i)
	for(var j=0;j<floating.size;++j)
	if(floating.getCell(i,j)){
		var x = i-offsetX;
		var y = j-offsetY;
		print(x+" "+y);
		if(x<0||y<0||x>=floating.size||y>=floating.size){
			movePiece(floating,board,floating.getCell(mouseDX/cs,mouseDY/cs).id,0,0);
			return;
		}
	}

	// successful move, place new poly and detect squares
	// (in this order so no new polys aren't near any detected-formed polys and new polys that happen to form squares get detected)
	movePiece(floating,board,floating.getCell(mouseDX/cs,mouseDY/cs).id,offsetX,offsetY);
	placeNewPoly();
});

canvas.onselectstart = function(){return false;};

//==  PROGRAM ENTRY  =========================================================//

(function main(){newGame();tick=new Date().getTime();update();})();

</script></body></html>
