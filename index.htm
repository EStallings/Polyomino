<!DOCTYPE html><html><head><title>Polyomino</title><meta charset="UTF-8">
<style>*{position:absolute;margin:0px;}</style></head>
<body bgcolor="000000"><canvas id="canvas" width="512" height="512"></canvas>
<script type="text/javascript">

/*+==========================================================================+*\
                   ___  ____  ____  ______  __  ________  ______ 
                  / _ \/ __ \/ /\ \/ / __ \/  |/  /  _/ |/ / __ \
                 / ___/ /_/ / /__\  / /_/ / /|_/ // //    / /_/ /
                /_/   \____/____//_/\____/_/  /_/___/_/|_/\____/ 

// TODO: fibonacci coloring
// TODO: truncating and order recalculating can lead to situations where unfulfilled next-order boxes occur

\*+==========================================================================+*/

var canvas = document.getElementById("canvas");
var gfx = canvas.getContext("2d");
var ww = canvas.width;
var wh = canvas.height;
var tick,elapsed;
var print = console.log; // DELETE
function rfloat(x){return Math.random()*x;}
function rInt(x){return Math.floor(Math.random()*x);}

//==  MISC RENDERING  ========================================================//

function setFillColor(r,g,b){gfx.fillStyle="rgb("+Math.floor(255*r)+","+Math.floor(255*g)+","+Math.floor(255*b)+")";}
function setStrokeColor(r,g,b){gfx.strokeStyle="rgb("+Math.floor(255*r)+","+Math.floor(255*g)+","+Math.floor(255*b)+")";}

function renderRect(x0,y0,x1,y1){
	gfx.beginPath();
	gfx.moveTo(x0,y0);
	gfx.lineTo(x0,y1);
	gfx.lineTo(x1,y1);
	gfx.lineTo(x1,y0);
	gfx.fill();
}

function renderLine(x0,y0,x1,y1){
	gfx.beginPath();
	gfx.moveTo(x0,y0);
	gfx.lineTo(x1,y1);
	gfx.stroke();
}

//==  GRID RELATED  ==========================================================//

var grid = function(size){
	var grid = [];
	grid.size = size;
	for(var i=0;i<size;++i){
		grid[i] = [];
		for(var j=0;j<size;++j)grid[i][j] = null;
	}

	grid.getCell = function(x,y){
		x = Math.floor(x);
		y = Math.floor(y);
		if(x<0||y<0||x>=grid.size||y>=grid.size)return undefined;
		return grid[x][y];
	}

	return grid;
}

var cell = function(id,order){
	this.id = id;
	this.order = order;
}

//==  GAME VARIABLES  ========================================================//

var polyColor = ["#f00","#0f0","#00f","#0ff","#f0f","#0ff","#fff"];
var board,blockId,floating,score;
var dragging,mouseDX,mouseDY,mouse;
var cellSize = 32;

function newId(){return ++blockId;}

//==  GAME FUNCTIONS  ========================================================//

function placeNewPoly(){
	var x,y;
	while(true){
		x = rInt(board.size);
		y = rInt(board.size);
		if(!board.getCell(x,y))break;
	}

	var id = newId();
	board[x][y] = new cell(id,1);
	switch(rInt(8)){
		case 0:if(board.getCell(x,y-1) === null){board[x][y-1] = new cell(id,2);board.getCell(x,y).order = 2;}break;
		case 1:if(board.getCell(x,y+1) === null){board[x][y+1] = new cell(id,2);board.getCell(x,y).order = 2;}break;
		case 2:if(board.getCell(x-1,y) === null){board[x-1][y] = new cell(id,2);board.getCell(x,y).order = 2;}break;
		case 3:if(board.getCell(x+1,y) === null){board[x+1][y] = new cell(id,2);board.getCell(x,y).order = 2;}break;
	}
}

function squareToPoly(x,y,order){
	outer:while(true){
		var filled = new grid(order,order);

		// clear everything in bounding box
		for(var i=x;i<x+order;++i)
		for(var j=y;j<y+order;++j)
			board[i][j] = null;

		// generate random polyomino
		var id = newId();
		var i=x+rInt(order);
		var j=y+rInt(order);
		board[i][j] = new cell(id,order);
		filled[i-x][j-y] = true;
		for(var count=1;count<order;++count)while(true){
			i=x+rInt(order);
			j=y+rInt(order);
			if(board[i][j])continue;
			var u = filled.getCell(i-x  ,j-y-1);
			var d = filled.getCell(i-x  ,j-y+1);
			var l = filled.getCell(i-x-1,j-y  );
			var r = filled.getCell(i-x+1,j-y  );
			if(!(u||d||l||r))continue;
			board[i][j] = new cell(id,order);
			filled[i-x][j-y] = true;
			break;
		}

		// assure poly has no holes
		var recurse = function(x,y){
			if(x<0||y<0||x>=filled.size||y>=filled.size)return;
			if(filled[x][y])return;
			filled[x][y] = true;
			recurse(x,y-1);
			recurse(x,y+1);
			recurse(x-1,y);
			recurse(x+1,y);
		};

		while(true){
			i=rInt(order);
			j=rInt(order);
			if(!filled[i][j])break;
		}recurse(i,j);

		for(var i=0;i<order;++i)
		for(var j=0;j<order;++j)
			if(!filled[i][j])continue outer;
		break;
	}
}

// TODO: GET RID OF THE RECURSION XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX XXX
function recalculateOrder(){
	for(var i=0;i<board.size;++i)
	for(var j=0;j<board.size;++j)
	if(board[i][j] !== null){
		// determine real order of cell
		var count = 0;
		var visited = new grid(board.size,board.size);
		var recurse = function(x,y){
			if(x<0||y<0||x>=visited.size||y>=visited.size)return;
			if(!board[x][y])return;
			if(board[i][j].id !== board[x][y].id)return;
			if(visited[x][y])return;
			visited[x][y] = true;
			++count;
			recurse(x,y-1);
			recurse(x,y+1);
			recurse(x-1,y);
			recurse(x+1,y);
		};

		recurse(i,j);

		// if counted order doesnt match assigned order, reassign
		if(count != board[i][j].order){
			var visited = new grid(board.size,board.size);
			var recurse = function(x,y){
				if(x<0||y<0||x>=visited.size||y>=visited.size)return;
				if(!board[x][y])return;
				if(board[i][j].id !== board[x][y].id)return;
				if(visited[x][y])return;
				visited[x][y] = true;
				board[x][y].order = count;
				recurse(x,y-1);
				recurse(x,y+1);
				recurse(x-1,y);
				recurse(x+1,y);
			};

			recurse(i,j);
		}
	}
}

function detectSquares(){
	for(var x=0;x<board.size;++x)
	outer:for(var y=0;y<board.size;++y)
	if(board[x][y]){
		var n = board[x][y].order;
		if(x+n>=board.size||y+n>=board.size)continue outer;
		for(var i=x;i<x+n+1;++i)
		for(var j=y;j<y+n+1;++j){
			var c = board.getCell(i,j);
			if(!c)continue outer;
			if(c.order !== n)continue outer;
		}
		squareToPoly(x,y,n+1);
	}recalculateOrder(); // placing this here rather than right after squareToPoly allows for comboing
	// TODO: recursively detectSquares AFTER a recalculateOrder
}

function update(){
	requestAnimationFrame(update);
	var currentTick = new Date().getTime();
	elapsed = currentTick-tick;
	tick = currentTick;

	// clear canvas
	gfx.clearRect(0,0,ww,wh);

	// render dot grid
	setFillColor(0.2,0.2,0.2);
	for(var i=0;i<board.size;++i)
	for(var j=0;j<board.size;++j)
		renderRect(i*cellSize+15,j*cellSize+15,(i+1)*cellSize-15,(j+1)*cellSize-15);

	// render polyominoes
	for(var i=0;i<board.size;++i)
	for(var j=0;j<board.size;++j){
		var cell = board[i][j];
		if(cell){
			gfx.fillStyle = polyColor[cell.order-1];
			renderRect(i*cellSize+1,j*cellSize+1,(i+1)*cellSize-1,(j+1)*cellSize-1);
			var right = board.getCell(i+1,j);
			if(right&&right.id === cell.id)renderRect((i+1)*cellSize-1,j*cellSize+1,(i+1)*cellSize+1,(j+1)*cellSize-1);
			var down = board.getCell(i,j+1);
			if(down&&down.id === cell.id)renderRect(i*cellSize+1,(j+1)*cellSize-1,(i+1)*cellSize-1,(j+1)*cellSize+1);
		}
	}

	// render floating
	if(dragging){
		gfx.save();
		gfx.translate(mouse.x-mouseDX,mouse.y-mouseDY);
		for(var i=0;i<floating.size;++i)
		for(var j=0;j<floating.size;++j){
			var cell = floating[i][j];
			if(cell){
				gfx.fillStyle = polyColor[cell.order-1];
				renderRect(i*cellSize+1,j*cellSize+1,(i+1)*cellSize-1,(j+1)*cellSize-1);
				var right = floating.getCell(i+1,j);
				if(right&&right.id === cell.id)renderRect((i+1)*cellSize-1,j*cellSize+1,(i+1)*cellSize+1,(j+1)*cellSize-1);
				var down = floating.getCell(i,j+1);
				if(down&&down.id === cell.id)renderRect(i*cellSize+1,(j+1)*cellSize-1,(i+1)*cellSize-1,(j+1)*cellSize+1);
			}
		}
		gfx.restore();
	}
}

function newGame(){
	board = new grid(16);
	blockId = 0;
	score = 0;
	dragging = false;
	for(var i=0;i<4;++i)placeNewPoly();
	detectSquares(); // should only combine when 4 1x1's make a 2x2...
}

//==  CONTROLS HANDLING  =====================================================//

function movePiece(from,to,id,offsetX,offsetY){
	for(var i=0;i<from.size;++i)
	for(var j=0;j<from.size;++j){
		var c = from.getCell(i+offsetX,j+offsetY);
		if(!c)continue;
		if(c.id !== id)continue;
		to[i][j] = c;
		from[i+offsetX][j+offsetY] = null;
	}
}

function getMousePos(evt){
	var rect = canvas.getBoundingClientRect();
	return{x:evt.clientX-rect.left,y:evt.clientY-rect.top};
}

canvas.addEventListener("mousedown",function(e){
	mouse = getMousePos(e);
	if(dragging)return; // if ive somehow glitched into this state, keep holding whats being held
	var c = board.getCell(mouse.x/cellSize,mouse.y/cellSize);
	if(!c)return;

	// move selected piece onto floating layer, remove from board
	dragging = true;
	mouseDX = mouse.x;
	mouseDY = mouse.y;
	var id = c.id;
	var order = c.order;
	floating = new grid(board.size);
	movePiece(board,floating,c.id,0,0);
});

canvas.addEventListener("mousemove",function(e){mouse = getMousePos(e);});

canvas.addEventListener("mouseup",function(e){
	mouse = getMousePos(e);
	if(dragging){
		dragging = false;

		// check if floating is dropped on original position
		if(Math.floor(mouseDX/cellSize) == Math.floor(mouse.x/cellSize) &&
		   Math.floor(mouseDY/cellSize) == Math.floor(mouse.y/cellSize)){
			movePiece(floating,board,floating.getCell(mouseDX/cellSize,mouseDY/cellSize).id,0,0);
			return;
		}

		// TODO: these seem off...
		var offsetX = Math.floor(mouseDX/cellSize)-Math.floor(mouse.x/cellSize);
		var offsetY = Math.floor(mouseDY/cellSize)-Math.floor(mouse.y/cellSize);

		// make sure pieces in floating and board aren't overlapping
		for(var i=0;i<board.size;++i)
		for(var j=0;j<board.size;++j)
		if(board.getCell(i,j))
		if(floating.getCell(i+offsetX,j+offsetY)){
			movePiece(floating,board,floating.getCell(mouseDX/cellSize,mouseDY/cellSize).id,0,0);
			return;
		}

		// TODO: make sure pieces in floating aren't out of bounds in board

		// successful move, place new poly and detect squares
		// (in this order so no new polys aren't near any detected-formed polys and new polys that happen to form squares get detected)
		movePiece(floating,board,floating.getCell(mouseDX/cellSize,mouseDY/cellSize).id,offsetX,offsetY);
		placeNewPoly();
		detectSquares();
	}
});

//==  PROGRAM ENTRY  =========================================================//

(function main(){newGame();tick=new Date().getTime();update();})();

</script></body></html>
