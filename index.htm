<!DOCTYPE html><html><head><title>Polyomino</title><meta charset="UTF-8">
<body bgcolor="000000"><canvas id="canvas" width="520" height="520"></canvas>
<div style="font:48px arial;letter-spacing:-3px;font-weight:800;color:white;">Polyomino</div>
<script type="text/javascript">

/*+==========================================================================+*\
                   ___  ____  ____  ______  __  ________  ______ 
                  / _ \/ __ \/ /\ \/ / __ \/  |/  /  _/ |/ / __ \
                 / ___/ /_/ / /__\  / /_/ / /|_/ // //    / /_/ /
                /_/   \____/____//_/\____/_/  /_/___/_/|_/\____/ 

\*+==========================================================================+*/

var canvas = document.getElementById("canvas");
var gfx = canvas.getContext("2d");
var ww = canvas.width;
var wh = canvas.height;
var tick,elapsed;
function rfloat(x){return Math.random()*x;}
function rInt(x){return Math.floor(Math.random()*x);}

//==  MISC RENDERING  ========================================================//

function rgb(r,g,b){gfx.fillStyle="rgb("+Math.floor(255*r)+","+Math.floor(255*g)+","+Math.floor(255*b)+")";}

function hsv(h,s,v){
	var r,g,b,i,f,p,q,t;
	if (h&&s===undefined&&v===undefined)s=h.s,v=h.v,h=h.h;
	i = Math.floor(h*6);
	f = h*6-i;
	p = v*(1-s);
	q = v*(1-f*s);
	t = v*(1-(1-f)*s);
	switch(i%6){
		case 0:r=v,g=t,b=p;break;
		case 1:r=q,g=v,b=p;break;
		case 2:r=p,g=v,b=t;break;
		case 3:r=p,g=q,b=v;break;
		case 4:r=t,g=p,b=v;break;
		case 5:r=v,g=p,b=q;break;
	}gfx.fillStyle="rgb("+Math.floor(255*r)+","+Math.floor(255*g)+","+Math.floor(255*b)+")";
}

function renderRect(x0,y0,x1,y1){
	gfx.beginPath();
	gfx.moveTo(x0,y0);
	gfx.lineTo(x0,y1);
	gfx.lineTo(x1,y1);
	gfx.lineTo(x1,y0);
	gfx.fill();
}

function keyframe(n){
	var scale = 150;
	return tick+n*scale;
}

//==  GRID RELATED  ==========================================================//

var grid = function(size){
	var grid = [];
	grid.size = size;
	for(var i=0;i<size;++i){
		grid[i] = [];
		for(var j=0;j<size;++j)grid[i][j] = null;
	}

	grid.setCell = function(x,y,c){
		x = Math.floor(x);
		y = Math.floor(y);
		if(x<0||y<0||x>=grid.size||y>=grid.size)return;
		grid[x][y] = c;
	}

	grid.getCell = function(x,y){
		x = Math.floor(x);
		y = Math.floor(y);
		if(x<0||y<0||x>=grid.size||y>=grid.size)return undefined;
		return grid[x][y];
	}

	return grid;
}

var polyCell = function(id,order){
	this.id = id;
	this.order = order;
}

var animCell = function(begin,end,inOutFade,direction){
	this.begin = begin;
	this.end = end;
	this.inOutFade = inOutFade;
	this.direction = direction;
}

//==  GAME VARIABLES  ========================================================//

var UP    = 0;
var DOWN  = 1;
var LEFT  = 2;
var RIGHT = 3;

var IN      = 0;
var OUT     = 1;
var OUTFADE = 2;

var goldenAngle = 0.381966;
var board,floating,active,anim;
var blockId,score;
var mouse,dragging,snapping,mouseDX,mouseDY,downGX,downGY,mouseGX,mouseGY;
var goalFloatX,goalFloatY,floatX,floatY;
var cs = 32;

function newId(){return ++blockId;}

function getInactiveCell(x,y){
	if(active.getCell(x,y))return undefined;
	return board.getCell(x,y);
}

function setAnim(x,y,begin,end,IOF,direction){
	active.setCell(x,y,true);
	anim.getCell(x,y).push(new animCell(begin,end,IOF,direction));
}

//==  VERIFICATION FUNCTIONS  ================================================//

function recurse(visited,x,y,c,f){
	var e = getInactiveCell(x,y);
	if(!e || c.id !== e.id)return;
	if(visited.getCell(x,y))return;
	visited.setCell(x,y,true);
	if(f)f(e);
	recurse(visited,x  ,y-1,c,f);
	recurse(visited,x  ,y+1,c,f);
	recurse(visited,x-1,y  ,c,f);
	recurse(visited,x+1,y  ,c,f);
};

// TODO: consider animations
function recalculateIds(){
	var visited = new grid(board.size);
	for(var i=0;i<board.size;++i)for(var j=0;j<board.size;++j){
		var c = getInactiveCell(i,j);
		if(!c)continue;
		recurse(visited,i,j,c);
		var id = newId();
		for(var x=0;x<board.size;++x)for(var y=0;y<board.size;++y){
			var chk = getInactiveCell(x,y);
			if(chk&&chk.id === c.id&&!visited.getCell(x,y))
				chk.id = id;
		}
	}
}

// TODO: consider animations
function recalculateOrder(){
	for(var i=0;i<board.size;++i)for(var j=0;j<board.size;++j){
		var c = getInactiveCell(i,j);
		if(!c)continue;

		// determine real order of cell
		var count = 0;
		recurse(new grid(board.size,board.size),
		        i,j,c,function(e){++count;});

		// if counted order doesnt match assigned order,reassign
		if(count === c.order)continue;
		recurse(new grid(board.size,board.size),
		        i,j,c,function(e){e.order = count;});
	}
}

function detectSquares(){
	var squareCount = 0;

	// initialize squares grid
	var squares = new grid(board.size);
	for(var i=0;i<squares.size;++i)for(var j=0;j<squares.size;++j)
		squares.setCell(i,j,0);

	// scan 1, detect any squares on the board
	for(var x=0;x<board.size;++x)
	outer:for(var y=0;y<board.size;++y){
		var c = getInactiveCell(x,y);
		if(c){
			// determine largest possible square order
			var minOrder = c.order+1;
			var maxOrder = minOrder;
			for(;Math.min(x+maxOrder,y+maxOrder)<=board.size;++maxOrder)
				if(getInactiveCell(x,y).order !== c.order)break;

			// for each possible order (smallest to largest)
			inner:for(var order=minOrder;order!=maxOrder;++order){
				// scan for square
				for(var i=x;i<x+order;++i)for(var j=y;j<y+order;++j){
					var e = getInactiveCell(i,j);
					if(!e)continue inner;
					if(e.order !== c.order)continue inner;
				}

				console.log(order);

				// if square exists, write to squares grid
				for(var i=x;i<x+order;++i)for(var j=y;j<y+order;++j)
					if(squares.getCell(i,j)<order)squares.setCell(i,j,order);
			}
		}
	}


	// scan 2, detect largest squares on squares grid
	for(var x=0;x<squares.size;++x)
	outer:for(var y=0;y<squares.size;++y){
		var c = squares.getCell(x,y);
		if(c<=0)continue;
		for(var i=x;i<x+c;++i)for(var j=y;j<y+c;++j)
			if(squares.getCell(i,j) != c)continue outer;
		for(var i=x;i<x+c;++i)for(var j=y;j<y+c;++j)
			squares.setCell(i,j,0);
		squareToPoly(x,y,c);
		++squareCount;
	}

	// placing these here rather than right after squareToPoly allows for comboing
	recalculateIds();                 // TODO: consider animations
	recalculateOrder();               // TODO: consider animations
	if(squareCount>0)detectSquares(); // TODO: consider animations
}

//==  GENERATION FUNCTIONS  ==================================================//

// TODO: detect endgame
function placeNewPoly(){
	var x,y;
	while(true){
		x = rInt(board.size);
		y = rInt(board.size);
		if(!getInactiveCell(x,y))break;
	}

	var id = newId();
	board.setCell(x,y,new polyCell(id,1));
	var formDomino = function(i,j,dir){
		if(getInactiveCell(i,j) !== null){
			setAnim(x,y,keyframe(1),keyframe(2),OUTFADE);
			setAnim(x,y,keyframe(0),keyframe(1),IN,dir);
		}else{
			setAnim(x,y,keyframe(2),keyframe(3),OUTFADE);
			setAnim(i,j,keyframe(2),keyframe(3),OUTFADE);
			setAnim(x,y,keyframe(0),keyframe(1),IN,dir);
			setAnim(i,j,keyframe(1),keyframe(2),IN,dir);
			board.setCell(i,j,new polyCell(id,2));
			board.getCell(x,y).order = 2;
		}
	}

	switch(rInt(4)){
		case 0:formDomino(x,y-1,UP);break;
		case 1:formDomino(x,y+1,DOWN);break;
		case 2:formDomino(x-1,y,LEFT);break;
		case 3:formDomino(x+1,y,RIGHT);break;
	}

	detectSquares(); // TODO: consider animations
}

 // TODO: consider animations
function squareToPoly(x,y,order){
	outer:while(true){
		var filled = new grid(order,order);

		// clear everything in bounding box
		for(var i=x;i<x+order;++i)for(var j=y;j<y+order;++j)
			board.setCell(i,j,null);

		// generate random polyomino
		var id = newId();
		var i=x+rInt(order);
		var j=y+rInt(order);
		board.setCell(i,j,new polyCell(id,order));
		filled.setCell(i-x,j-y,true);
		for(var count=1;count<order;++count)while(true){
			i=x+rInt(order);
			j=y+rInt(order);
			if(board.getCell(i,j))continue;
			var u = filled.getCell(i-x  ,j-y-1);
			var d = filled.getCell(i-x  ,j-y+1);
			var l = filled.getCell(i-x-1,j-y  );
			var r = filled.getCell(i-x+1,j-y  );
			if(!(u||d||l||r))continue;
			board.setCell(i,j,new polyCell(id,order));
			filled.setCell(i-x,j-y,true);
			break;
		}

		// assure poly has no holes
		var recurse = function(x,y){
			var c = filled.getCell(x,y);
			if(c||c===undefined)return;
			filled.setCell(x,y,true);
			recurse(x  ,y-1);
			recurse(x  ,y+1);
			recurse(x-1,y  );
			recurse(x+1,y  );
		};

		while(true){
			i=rInt(order);
			j=rInt(order);
			if(!filled.getCell(i,j))break;
		}recurse(i,j);

		for(var i=0;i<order;++i)for(var j=0;j<order;++j)
			if(!filled.getCell(i,j))continue outer;
		break;
	}
}

//==  MAIN LOOP  =============================================================//

function notAnimating(x,y){
	var c = anim.getCell(x,y);
	c = c[c.length-1];
	if(!c)return true;
	if(c.inOutFade === IN || c.inOutFade === OUT)return false;
	return true;
}

function renderGrid(g){
	var hue = function(order){return (order*goldenAngle)%1;}

	for(var i=0;i<g.size;++i)for(var j=0;j<g.size;++j){
		var c = g.getCell(i,j);
		if(c && notAnimating(i,j)){
			hsv(hue(c.order),1,0.6);
			renderRect(i*cs+1,j*cs+1,(i+1)*cs-1,(j+1)*cs-1);
			var right = g.getCell(i+1,j);
			if(right&&right.id === c.id)renderRect((i+1)*cs-2,j*cs+1,(i+1)*cs+2,(j+1)*cs-1);
			var down = g.getCell(i,j+1);
			if(down&&down.id === c.id)renderRect(i*cs+1,(j+1)*cs-2,(i+1)*cs-1,(j+1)*cs+2);
		}
	}

	for(var i=0;i<g.size;++i)for(var j=0;j<g.size;++j){
		var c = g.getCell(i,j);
		if(c && notAnimating(i,j)){
			hsv(hue(c.order),1,1);
			renderRect(i*cs+3,j*cs+3,(i+1)*cs-3,(j+1)*cs-3);
			var right = g.getCell(i+1,j);
			if(right&&right.id === c.id)renderRect((i+1)*cs-4,j*cs+3,(i+1)*cs+4,(j+1)*cs-3);
			var down = g.getCell(i,j+1);
			if(down&&down.id === c.id)renderRect(i*cs+3,(j+1)*cs-4,(i+1)*cs-3,(j+1)*cs+4);
		}
	}
}

function render(){
	var currentTick = new Date().getTime();
	elapsed = currentTick-tick;
	tick = currentTick;
	var currentlyAnimating = false;
	var triggerDetectSquares = false;
	gfx.clearRect(0,0,ww,wh);
	gfx.save();
	gfx.translate(4,4);

	// render grid lines
	rgb(0.2,0.2,0.2);
	for(var i=1;i<board.size;++i)for(var j=1;j<board.size;++j){
		renderRect(i*cs-4,j*cs-1,i*cs+4,j*cs+1);
		renderRect(i*cs-1,j*cs-4,i*cs+1,j*cs+4);
	}

	// render grid cells
	for(var i=0;i<board.size;++i)for(var j=0;j<board.size;++j){
		rgb(0.02,0.02,0.02);
		renderRect(i*cs+2,j*cs+2,(i+1)*cs-2,(j+1)*cs-2);
	}

	// render board and animations
	renderGrid(board);
	for(var i=0;i<board.size;++i)for(var j=0;j<board.size;++j){
		var cLs = anim.getCell(i,j);
		var c = cLs[cLs.length-1];
		if(!c)continue;
		currentlyAnimating = true;
		if(tick>c.end){
			cLs.pop();
			c = cLs[cLs.length-1];
			if(!c){
				active.setCell(i,j,null);
				triggerDetectSquares = true;
				continue;
			}
		}

		switch(c.inOutFade){
			case IN:
				if(tick>c.begin){
					rgb(1,1,1);
					var interp = (tick-c.begin)/(c.end-c.begin);
					switch(c.direction){
						case UP:   renderRect(i*cs,(j+1)*cs-interp*cs,(i+1)*cs,(j+1)*cs);break;
						case DOWN: renderRect(i*cs,j*cs,(i+1)*cs,j*cs+interp*cs);break;
						case LEFT: renderRect((i+1)*cs-interp*cs,j*cs,(i+1)*cs,(j+1)*cs);break;
						case RIGHT:renderRect(i*cs,j*cs,i*cs+interp*cs,(j+1)*cs);break;
					}
				}break;
			case OUT:
				if(tick<c.begin){
					rgb(1,1,1);
				}else{
				}break;
			case OUTFADE:
				if(tick<c.begin)rgb(1,1,1);
				else{
					var interp = 1-(tick-c.begin)/(c.end-c.begin);
					gfx.fillStyle = "rgba(255,255,255,"+interp+")";
				}renderRect(i*cs,j*cs,(i+1)*cs,(j+1)*cs);
				break;
		}
	}

	// render floating layer
	if(dragging){
		currentlyAnimating = true;
		floatX += (goalFloatX-floatX)*0.3;
		floatY += (goalFloatY-floatY)*0.3;

		gfx.save();
		gfx.translate(-floatX,-floatY);
		renderGrid(floating);
		gfx.restore();

		// break animation if snapping is complete
		if(snapping &&
		   Math.abs(floatX-goalFloatX)<0.5 &&
		   Math.abs(floatY-goalFloatY)<0.5){
			for(var i=0;i<floating.size;++i)for(var j=0;j<floating.size;++j)
			if(floating.getCell(i,j))
				active.setCell(i,j,null);
			movePiece(floating,board,floating.getCell(mouseDX/cs,mouseDY/cs).id,0,0);
			dragging = snapping = false;
		}
	}

	gfx.restore();
	if(triggerDetectSquares)detectSquares();
	if(currentlyAnimating)requestAnimationFrame(render);
}

function newGame(){
	var size = 16;
	board = new grid(size);
	active = new grid(size);
	anim = new grid(size);
	for(var i=0;i<anim.size;++i)for(var j=0;j<anim.size;++j)
		anim.setCell(i,j,[]);
	blockId = 0;
	score = 0;
	dragging = false;
	snapping = false;
	for(var i=0;i<4;++i)placeNewPoly();
}

//==  CONTROLS HANDLING  =====================================================//

function movePiece(from,to,id,offsetX,offsetY){
	for(var i=0;i<from.size;++i)for(var j=0;j<from.size;++j){
		var c = from.getCell(i+offsetX,j+offsetY);
		if(!c)continue;
		if(c.id !== id)continue;
		to.setCell(i,j,c);
		from.setCell(i+offsetX,j+offsetY,null);
	}
}

function calcMouseGridVars(){
	downGX  = Math.floor(mouseDX/cs);
	downGY  = Math.floor(mouseDY/cs);
	mouseGX = Math.floor(mouse.x/cs);
	mouseGY = Math.floor(mouse.y/cs);
}

function getMousePos(evt){
	var rect = canvas.getBoundingClientRect();
	return{x:evt.clientX-rect.left,y:evt.clientY-rect.top};
}

canvas.addEventListener("mousedown",function(e){
	mouse = getMousePos(e);
	if(dragging)return;
	var c = getInactiveCell(mouse.x/cs,mouse.y/cs);
	if(!c)return;

	// move selected piece onto floating layer,remove from board
	dragging = true;
	var id = c.id;
	var order = c.order;
	floating = new grid(board.size);
	movePiece(board,floating,c.id,0,0);

	mouseDX = mouse.x;
	mouseDY = mouse.y;
	calcMouseGridVars();
	floatX = goalFloatX = (downGX-mouseGX)*cs;
	floatY = goalFloatY = (downGY-mouseGY)*cs;

	render();
});

canvas.addEventListener("mousemove",function(e){
	mouse = getMousePos(e);
	if(!dragging||snapping)return;
	calcMouseGridVars();
	goalFloatX = (downGX-mouseGX)*cs;
	goalFloatY = (downGY-mouseGY)*cs;
});

canvas.addEventListener("mouseup",function(e){
	mouse = getMousePos(e);
	if(!dragging||snapping)return;

	calcMouseGridVars();
	var offsetX = downGX-mouseGX;
	var offsetY = downGY-mouseGY;

	var revert = function(){
		for(var i=0;i<floating.size;++i)for(var j=0;j<floating.size;++j)
		if(floating.getCell(i,j))
			active.setCell(i,j,true);
		goalFloatX = goalFloatY = 0;
		snapping = true;
	};

	// check if floating is dropped on original position
	if(downGX == mouseGX && downGY == mouseGY){revert();return;}

	// make sure pieces in floating and board aren't overlapping
	for(var i=0;i<board.size;++i)for(var j=0;j<board.size;++j)
	if(board.getCell(i,j))
	if(floating.getCell(i+offsetX,j+offsetY)){revert();return;}

	// make sure pieces in floating aren't out of bounds in board
	for(var i=0;i<floating.size;++i)for(var j=0;j<floating.size;++j)
	if(floating.getCell(i,j)){
		var x = i-offsetX;
		var y = j-offsetY;
		if(x<0||y<0||x>=floating.size||y>=floating.size){revert();return;}
	}

	// successful move, place new poly
	movePiece(floating,board,floating.getCell(mouseDX/cs,mouseDY/cs).id,offsetX,offsetY);
	placeNewPoly();
	dragging = false;
});

canvas.onselectstart = function(){return false;};

//==  PROGRAM ENTRY  =========================================================//

(function main(){tick=new Date().getTime();newGame();render();})();

</script></body></html>
